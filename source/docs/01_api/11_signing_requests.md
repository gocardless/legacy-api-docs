# Signing requests

**The process of creating signatures can be handled by GoCardless client libraries.**

The process for generating the signature broadly follows the process described in the OAuth 1.0 spec (RFC 5849, ยง3.4). The complete process is outlined in more detail below.

## Signature Guide

You'll only need this guide if you're writing your own client library in another language - otherwise, we'll cover all of this for you.

This is used widely throughout the "Connect" web interface and webhooks. The signature ensures that data transmitted over insecure connections cannot be tampered with by attackers.

The process for generating the signature broadly follows the process described in the OAuth 1.0 spec (RFC 5849, ยง3.4).

There is a handy "Signature tool" in the Developer Panel that takes a JSON object, generates a percent-encoded string and signs it with your app secret. Check it out if you're having problems.

## Constructing the parameter array

The initial set of parameters is a dictionary mapping parameter names to values. The values may be primitive types (strings, integers) or complex types (arrays, dictionaries). The first step is to convert the dictionary to an array of key-value pairs. If there are any complex values, the dictionary will need to be flattened so that each leaf-level value is promoted to a top-level key-value pair in the resulting array. The following scheme is used for constructing the keys of promoted values:

Values inside arrays each take the array's key, with a set of empty square brackets appended to the end:

	{ cars: ['BMW', 'Fiat', 'VW'] }

Becomes:

	[ ['cars[]', 'BMW'], ['cars[]', 'Fiat'], ['cars[]', 'VW'] ]

Key-value pairs in nested dictionaries follow a similar scheme. The top-level key is generated by adding `'[' + key + ']'` to the parent dictionary's key:

	{ user: { name: 'Fred', age: 30 } }

Becomes:

	[ ['user[name]', 'Fred' ], ['user[age]', '30' ] ]

These rules are used in combination to convert the dictionary to an array:

	{ user: { name: 'Fred', cars: ['BMW', 'Fiat'] } }

Becomes:

	[ ['user[name]', 'Fred'], ['user[cars][]', 'BMW'], ['user[cars][]', 'Fiat' ] ]

## Normalizing the parameters

Both the key and value in each pair are percent-encoded according to RFC 5849, ยง3.6. Note that the standard URL and query-string encoding functions in most languages are not by default compliant with the RFC. Language specific examples are provided below.

	[ ['user[email]', 'fred@example.com' ], ['user[age]', '30' ] ]

Becomes:

	[ ['user%5Bemail%5D', 'fred%40example.com' ], ['user%5Bage%5D', '30' ] ]

Sort the request parameter key-value pairs by key in ascending byte order. If two keys are equal, then they are sorted by value.

	[ ['user%5Bemail%5D', 'fred%40example.com' ], ['user%5Bage%5D', '30' ] ]

Becomes:

	[ ['user%5Bage%5D', '30' ], ['user%5Bemail%5D', 'fred%40example.com' ] ]

Each of the key-value pairs are joined by an '=' sign:

	[ ['user%5Bage%5D', '30' ], ['user%5Bemail%5D', 'fred%40example.com' ] ]

Becomes:

	[ 'user%5Bage%5D=30', 'user%5Bemail%5D=fred%40example.com' ]

The resulting array of strings is joined by '&' signs: e.g

	[ ['user%5Bage%5D', '30' ], ['user%5Bemail%5D', 'fred%40example.com' ] ]

Becomes:

	'user%5Bage%5D=30&user%5Bemail%5D=fred%40example.com'

## Signing the parameters

Create a HMAC-SHA256 digest of the normalized string, using the  `app secret` (available in Developer Panel) as the key.

	App secret: '5PUZmVMmukNwiHc7V/TJvFHRQZWZumIpCnfZKrVYGpuAdkCcEfv3LIDSrsJ+xOVH'
	Parameters: 'user%5Bage%5D=30&user%5Bemail%5D=fred%40example.com'
	Signature: '763f02cb9f998a5e06fda2b790bedd503ba1a34fd7cbf9e22f8ce562f73f0470'

The hexadecimal representation of the signature should be included as a request parameter named signature. The complete request would look like:

	https://gocardless.com/connect/subscriptions/new?client_id=3QmpV5yi8Ii9Rc2uCwalWRsqkpibtk5ISOk%2FF%2BoyzrOoNpjGguZ4IRn2379agARS&nonce=DGsrJuOpuT%2FUlhM6Ok5gcpod0447E%2F4RJvx%2BG1Xa0eZnb2uRDF9VRRMj00Rj&signature=f6b9e6cd8eef30c444da48370e646839c9bb9e1cf10ea16164d5cf93a50231eb&subscription%5Bamount%5D=1&subscription%5Bdescription%5D=gold&subscription%5Binterval_length%5D=1&subscription%5Binterval_unit%5D=day&subscription%5Bmerchant_id%5D=WOQRUJU9OH2HH1&timestamp=2011-01-01T08%3A00%3A00Z

### Examples

**Node JS:**

```javascript
var crypto = require('crypto');
var _ = require('lodash');

function encode(str) {
  return encodeURIComponent(str)
    .replace(/!/g, '%21')
    .replace(/'/g, '%27')
    .replace(/\(/g, '%28')
    .replace(/\)/g, '%29')
    .replace(/\*/g, '%2A');
}

function concat(array) {
  return Array.prototype.concat.apply([], array);
}

function toQuery(params, ns) {
  // Recurse if params is an array
  if (_.isArray(params)) {
    return concat(params.map(function(v) {
      return toQuery(v, ns + '[]');
    }));
  }

  if (_.isObject(params)) {
    var pairs = concat(Object.keys(params).map(function(key) {
      return toQuery(params[key], (ns ? ns + '[' + key + ']' : key));
    }));

    if (ns) return pairs;

    return pairs.sort(function(a, b) {
      return a.join('\0') < b.join('\0') ? -1 : (a === b ? 0 : 1);
    }).map(function(pair) {
      return pair.join('=');
    }).join('&');
  }

  return [[encode(ns), encode(params)]];
}

function sign(query, secret) {
  return crypto.createHmac('sha256', secret).update(query).digest('hex');
}

var signature = sign(toQuery(myParams), mySecret);
```
